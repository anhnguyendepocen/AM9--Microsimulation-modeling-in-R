Costs <- function (M_it) {
# M_it: current health state
c_it <- c()
c_it[M_it == "dead"]    <- c_D     # costs at dead state
c_it[M_it == "healthy"] <- c_H     # costs accrued by being healthy this cycle
c_it[M_it == "sick"]    <- c_S     # costs accrued by being sick this cycle
return(c_it)  # return costs accrued this cycle
}
#### 05.3 Health outcome function ####
# The Effs function to update the utilities at every cycle.
Effs <- function (M_it) {
# M_it: current health state
q_it <- c()
q_it[M_it == "dead"]    <- u_D     # QALYs at dead state
q_it[M_it == "healthy"] <- u_H     # QALYs accrued by being healthy this cycle
q_it[M_it == "sick"]    <- u_S     # QALYs accrued by being sick this cycle
return(q_it)  # return the QALYs accrued this cycle
}
#### 06 Run Microsimulation ####
MicroSim <- function(n_i, df_X, seed = 1) {
# Arguments:
# n_i:     number of individuals
# df_X     data frame with individual data
# Sex      sex of the indivuduals
# seed:    defauls is 1
set.seed(seed) # set the seed
n_s <- length(v_n) # the number of health states
# create three matrices called m_M, m_C and m_E
# number of rows is equal to the n_i, the number of columns is equal to n_t (the initial state and all the n_t cycles)
# m_M is used to store the health state information over time for every individual
# m_C is used to store the costs information over time for evey individual
# m_E is used to store the effects information over time for every individual
m_M <- m_C <- m_E <-  matrix(nrow = n_i, ncol = n_t + 1,
dimnames = list(paste("ind"  , 1:n_i, sep = " "),
paste("cycle", 0:n_t, sep = " ")))
m_M[, 1] <- v_M_init          # initial health state for individual i
v_Ts      <- v_Ts_init        # initialize time since illnes onset for individual i
m_C[, 1] <- Costs(m_M[, 1])   # costs accrued individual i during cycle 0
m_E[, 1] <- Effs(m_M[, 1])    # QALYs accrued individual i during cycle 0
# open a loop for time running cycles 1 to n_t
for (t in 1:n_t) {
v_p <- Probs(m_M[, t], df_X, v_Ts, t)  # calculate the transition probabilities for the cycle based on health state t
m_M[, t + 1]  <- samplev(v_p, 1)       # sample the current health state and store that state in matrix m_M
m_C[, t + 1]  <- Costs(m_M[, t + 1])   # calculate costs per individual during cycle t + 1
m_E[, t + 1]  <- Effs (m_M[, t + 1])   # calculate QALYs per individual during cycle t + 1
v_Ts <- ifelse(m_M[, t + 1] == "sick", v_Ts + 1, 0) # update time since illness onset for t + 1
# Display simulation progress
if(t/(n_t/10) == round(t/(n_t/10), 0)) { # display progress every 10%
cat('\r', paste(t/n_t * 100, "% done", sep = " "))
}
} # close the loop for the time points
# calculate
tc <- m_C %*% v_dwc    # total (discounted) cost per individual
te <- m_E %*% v_dwe    # total (discounted) QALYs per individual
tc_hat <- mean(tc)     # average (discounted) cost
te_hat <- mean(te)     # average (discounted) QALYs
# store the results from the simulation in a list
results <- list(m_M = m_M, m_C = m_C, m_E = m_E, tc = tc , te = te, tc_hat = tc_hat, te_hat = te_hat)
return(results)  # return the results
} # end of the MicroSim function
# By specifying all the arguments in the `MicroSim()` the simulation can be started
# In this example the outcomes are of the simulation are stored in the variables `outcomes_no_tr` and `outcomes_trt`.
# Run the simulation model
outcomes <- MicroSim(n_i, df_X, seed = 1)
# Show results
results  <- data.frame("Total Cost" = outcomes$tc_hat, "Total QALYs" = outcomes$te_hat)
results
#### 07 Visualize results ####
options(scipen = 999)
plot_tc(outcomes$tc)    # density of total costs
# ggsave("figs/microoutcomes_sick_sicker/microoutcomes_sick_sicker_cost_density_no_trt.png", plot = plot_tc(outcomes_no_trt$tc), width = 8, height = 6)
plot_te(outcomes$te)    # density of total QALYs
# ggsave("figs/microoutcomes_sick_sicker/microoutcomes_sick_sicker_eff_density_no_trt.png", plot = plot_te(outcomes_no_trt$te), width = 8, height = 6)
plot_m_TR(outcomes$m_M) # health state trace
# ggsave("figs/microoutcomes_sick_sicker/microoutcomes_sick_sicker_eff_density_trt.png", plot = plot_te(outcomes_trt$te), width = 8, height = 6)
#### 08 Probabilistic Sensitivity Analysis (PSA) ####
### Function that generates random sample for PSA
gen_psa <- function(n_sim = 1000, seed = 071818){
set.seed(seed) # set a seed to be able to reproduce the same results
df_psa <- data.frame(
# Transition probabilities (per cycle)
p_HS    = rbeta(n_sim, 24, 450)                        , # probability to become sick when healthy
p_SD    = rbeta(n_sim, 10, 89)                         , # probability to die when sick
# Cost vectors with length n_sim
c_H     = rgamma(n_sim, shape = 225, scale = 6.65)     , # cost of remaining one cycle in state H
c_S     = rgamma(n_sim, shape = 625, scale = 8)        , # cost of remaining one cycle in state S1
c_D     = 0                                            , # cost of being in the death state
# Utility vectors with length n_sim
u_H     = rbeta(n_sim, 9, 0.009)                       , # utility when healthy
u_S     = rbeta(n_sim ,10, 1.75)                       , # utility when sick
u_D     = 0                                              # utility when dead
)
return(df_psa)
}
# Try it
gen_psa(10)
### Decrease number of individuals since PSA takes a lot of time
n_i <- 50
### update Sample individual level characteristics
# Static characteristics
v_sex    <- sample(x = c("Female", "Male"), prob = c(0.5, 0.5), size = n_i, replace = TRUE) # randomly sample the sex of an individual (50% female)
df_X     <- data.frame(ID = 1:n_i, Sex = v_sex)
# Dynamic characteristics
# Specify the initial health state of the individuals
# everyone begins in the healthy state (in this example)
v_M_init <- rep("healthy", times = n_i)
v_Ts_init <- rep(0, n_i)         # a vector with the time of being sick at the start of the model
### Number of simulations
n_sim <- 1000
### Generate PSA input dataset
df_psa_input <- gen_psa(n_sim = n_sim)
## First six observations
head(df_psa_input)
## Histogram of parameters
ggplot(melt(df_psa_input, variable.name = "Parameter"), aes(x = value)) +
facet_wrap(~Parameter, scales = "free") +
geom_histogram(aes(y = ..density..)) +
theme_bw(base_size = 16)
# ggsave("figs/microsim_sick_sicker/microsim_sicksicker_PSA_parameters.png", width = 10, height = 6)
### Initialize dataframes with PSA output
# Dataframe of costs
df_c <- as.data.frame(matrix(0,
nrow = n_sim,
ncol = 1))
# Dataframe of effectiveness
df_e <- as.data.frame(matrix(0,
nrow = n_sim,
ncol = 1))
#### 08.1 Load function of microsimulation model ####
source("Function_Microsim_3-state_time.R")
# Test microsimulation function
calculate_ce_out(df_psa_input[1,])
#### 08.2 Run microsimulation model on each parameter set of PSA input dataset
for(i in 1:n_sim){
df_out_temp <- calculate_ce_out(df_psa_input[i, ])
df_c[i, ] <- df_out_temp$Cost
df_e[i, ] <- df_out_temp$Effect
# Display simulation progress
if(i/(n_sim/10) == round(i/(n_sim/10),0)) { # display progress every 10%
cat('\r', paste('            ', 'Overall: ', i/n_sim * 100, "% done", sep = " "))
}
}
;;i
i
# Test microsimulation function
calculate_ce_out(df_psa_input[2,])
df_psa_input
#### 08.1 Load function of microsimulation model ####
source("Function_Microsim_3-state_time.R")
# Test microsimulation function
calculate_ce_out(df_psa_input[1,])
nrow(calculate_ce_out(df_psa_input[1,]))
nrow(df_X)
#### 08 Probabilistic Sensitivity Analysis (PSA) ####
### Function that generates random sample for PSA
gen_psa <- function(n_sim = 1000, seed = 071818){
set.seed(seed) # set a seed to be able to reproduce the same results
df_psa <- data.frame(
# Transition probabilities (per cycle)
p_HS    = rbeta(n_sim, 24, 450)                        , # probability to become sick when healthy
# Cost vectors with length n_sim
c_H     = rgamma(n_sim, shape = 225, scale = 6.65)     , # cost of remaining one cycle in state H
c_S     = rgamma(n_sim, shape = 625, scale = 8)        , # cost of remaining one cycle in state S1
c_D     = 0                                            , # cost of being in the death state
# Utility vectors with length n_sim
u_H     = rbeta(n_sim, 9, 0.009)                       , # utility when healthy
u_S     = rbeta(n_sim ,10, 1.75)                       , # utility when sick
u_D     = 0                                              # utility when dead
)
return(df_psa)
}
# Try it
gen_psa(10)
### Decrease number of individuals since PSA takes a lot of time
n_i <- 50
### update Sample individual level characteristics
# Static characteristics
v_sex    <- sample(x = c("Female", "Male"), prob = c(0.5, 0.5), size = n_i, replace = TRUE) # randomly sample the sex of an individual (50% female)
df_X     <- data.frame(ID = 1:n_i, Sex = v_sex)
# Dynamic characteristics
# Specify the initial health state of the individuals
# everyone begins in the healthy state (in this example)
v_M_init <- rep("healthy", times = n_i)
v_Ts_init <- rep(0, n_i)         # a vector with the time of being sick at the start of the model
### Number of simulations
n_sim <- 1000
### Generate PSA input dataset
df_psa_input <- gen_psa(n_sim = n_sim)
### Initialize dataframes with PSA output
# Dataframe of costs
df_c <- as.data.frame(matrix(0,
nrow = n_sim,
ncol = 1))
# Dataframe of effectiveness
df_e <- as.data.frame(matrix(0,
nrow = n_sim,
ncol = 1))
#### 08.1 Load function of microsimulation model ####
source("Function_Microsim_3-state_time.R")
# Test microsimulation function
calculate_ce_out(df_psa_input[1,])
###############  simple 3-state microsimulation model              #############
# Includes:
# individual characteristics: sex
################################################################################
# Developed by:
# the Decision Analysis in R for Technologies in Health (DARTH) group
# Fernando Alarid-Escudero, PhD (1)
# Eva A. Enns, MS, PhD (1)
# M.G. Myriam Hunink, MD, PhD (2,3)
# Hawre J. Jalal, MD, PhD (4)
# Eline M. Krijkamp, MSc (2)
# Petros Pechlivanoglou, PhD (5)
# In collaboration of:
# 1 University of Minnesota School of Public Health, Minneapolis, MN, USA
# 2 Erasmus MC, Rotterdam, The Netherlands
# 3 Harvard T.H. Chan School of Public Health, Boston, USA
# 4 University of Pittsburgh Graduate School of Public Health, Pittsburgh, PA, USA
# 5 The Hospital for Sick Children, Toronto and University of Toronto, Toronto ON, Canada
################################################################################
# Please cite our publications when using this code
# darthworkgroup.com
## Jalal H, et al. An Overview of R in Health Decision Sciences.
# Med. Decis. Making. 2017; 37(3): 735-746.
## Krijkamp EM, et al. Microsimulation modeling for health decision sciences
# using R: a tutorial. Med. Decis. Making. 2018; 38(3): 400-422.
################################################################################
# Copyright 2017,
# THE HOSPITAL FOR SICK CHILDREN AND THE COLLABORATING INSTITUTIONS.
# All rights reserved in Canada, the United States and worldwide.
# Copyright, trademarks, trade names and any and all associated intellectual
# property are exclusively owned by THE HOSPITAL FOR SICK CHILDREN and the
# collaborating institutions and may not be used, reproduced, modified,
# distributed or adapted in any way without written permission.
################################################################################
rm(list = ls())  # Delete everything that is in R's memory
setwd(dirname(rstudioapi::getActiveDocumentContext()$path))  #set working directory as the folder where the course material is stored
#### 01 Load packages ####
library(plyr)     # load plyr including the useful join function
library(dampack)  # for CEA, PSA, and visualization
library(reshape2) # for data manipulation
#### 02 Load Functions ####
source("Functions.R")
#### 03 Input Model Parameters ####
set.seed(1)  # set the seed
# Model structure
v_n   <- c("healthy", "sick", "dead")          # vector with state names
n_s   <- length(v_n)                           # number of states
n_t   <- 60                                    # number of cycles
n_i   <- 10000                                 # number of individuals
d_r   <- 3                                     # discount rate of 3% per cycle
v_dwe <- v_dwc <- 1 / ((1 + d_r) ^ (0:n_t))    # discount weight
# Transition probabilities
p_HS <- 0.05      # probability healthy -> sick
p_SD <- c(0.1, 0.2, 0.3, 0.4, 0.5, rep(0.7, n_t - 5)) # probability to die in sick state by cycle
# Costs inputs
c_H  <- 1500      # cost of one cycle in healthy state
c_S  <- 5000      # cost of one cycle in sick state
c_D  <- 0
# utility inputs
u_H  <- 1         # utility when healthy
u_S  <- 0.85      # utility when sick
u_D  <- 0         # utility when dead
#### 04 Sample individual level characteristics ####
#### 04.1 Static characteristics ####
v_sex    <- sample(x = c("Female", "Male"), prob = c(0.5, 0.5), size = n_i, replace = TRUE) # randomly sample the sex of an individual (50% female)
df_X     <- data.frame(ID = 1:n_i, Sex = v_sex)
#### 04.2 Dynamic characteristics
# Specify the initial health state of the individuals
# everyone begins in the healthy state (in this example)
v_M_init  <- rep("healthy", times = n_i)
v_Ts_init <- rep(0, n_i)  # a vector with the time of being sick at the start of the model
#### 05 Define Simulation Functions ####
#### 05.1 Probability function ####
# The Probs function that updates the transition probabilities of every cycle is shown below.
Probs <- function(M_it, df_X, v_Ts, t) {
# Arguments:
# M_it: health state occupied by individual i at cycle t (character variable)
# t:     current cycle
# Returns:
#   transition probabilities for that cycle
m_p_it           <- matrix(0, nrow = n_s, ncol = n_i)  # create matrix of state transition probabilities
rownames(m_p_it) <-  v_n                               # give the state names to the rows
# lookup baseline probability and rate of dying based on individual characteristics
p_mort   <- data.frame(Sex = c("Female", "Male"), p_HD = c(0.0382, 0.0463))
p_HD_all <- join(df_X, p_mort, by = c("Sex") )
p_HD     <- p_HD_all[M_it == "healthy","p_HD"]
# update the v_p with the appropriate probabilities
# update m_p_it with the appropriate probabilities
m_p_it[, M_it == "healthy"] <- rbind(1 - p_HD - p_HS, p_HS, p_HD)    # transition probabilities when healthy
m_p_it[, M_it == "sick"]    <- rbind(0, 1 - p_SD[v_Ts], p_SD[v_Ts])  # transition probabilities when sick
m_p_it[, M_it == "dead"]    <- c(0, 0, 1)                            # transition probabilities when dead
return(t(m_p_it))
}
#### 05.2 Cost function ####
# The Costs function estimates the costs at every cycle.
Costs <- function (M_it) {
# M_it: current health state
c_it <- c()
c_it[M_it == "dead"]    <- c_D     # costs at dead state
c_it[M_it == "healthy"] <- c_H     # costs accrued by being healthy this cycle
c_it[M_it == "sick"]    <- c_S     # costs accrued by being sick this cycle
return(c_it)  # return costs accrued this cycle
}
#### 05.3 Health outcome function ####
# The Effs function to update the utilities at every cycle.
Effs <- function (M_it) {
# M_it: current health state
q_it <- c()
q_it[M_it == "dead"]    <- u_D     # QALYs at dead state
q_it[M_it == "healthy"] <- u_H     # QALYs accrued by being healthy this cycle
q_it[M_it == "sick"]    <- u_S     # QALYs accrued by being sick this cycle
return(q_it)  # return the QALYs accrued this cycle
}
#### 06 Run Microsimulation ####
MicroSim <- function(n_i, df_X, seed = 1) {
# Arguments:
# n_i:     number of individuals
# df_X     data frame with individual data
# Sex      sex of the indivuduals
# seed:    defauls is 1
set.seed(seed) # set the seed
n_s <- length(v_n) # the number of health states
# create three matrices called m_M, m_C and m_E
# number of rows is equal to the n_i, the number of columns is equal to n_t (the initial state and all the n_t cycles)
# m_M is used to store the health state information over time for every individual
# m_C is used to store the costs information over time for evey individual
# m_E is used to store the effects information over time for every individual
m_M <- m_C <- m_E <-  matrix(nrow = n_i, ncol = n_t + 1,
dimnames = list(paste("ind"  , 1:n_i, sep = " "),
paste("cycle", 0:n_t, sep = " ")))
m_M[, 1] <- v_M_init          # initial health state for individual i
v_Ts      <- v_Ts_init        # initialize time since illnes onset for individual i
m_C[, 1] <- Costs(m_M[, 1])   # costs accrued individual i during cycle 0
m_E[, 1] <- Effs(m_M[, 1])    # QALYs accrued individual i during cycle 0
# open a loop for time running cycles 1 to n_t
for (t in 1:n_t) {
v_p <- Probs(m_M[, t], df_X, v_Ts, t)  # calculate the transition probabilities for the cycle based on health state t
m_M[, t + 1]  <- samplev(v_p, 1)       # sample the current health state and store that state in matrix m_M
m_C[, t + 1]  <- Costs(m_M[, t + 1])   # calculate costs per individual during cycle t + 1
m_E[, t + 1]  <- Effs (m_M[, t + 1])   # calculate QALYs per individual during cycle t + 1
v_Ts <- ifelse(m_M[, t + 1] == "sick", v_Ts + 1, 0) # update time since illness onset for t + 1
# Display simulation progress
if(t/(n_t/10) == round(t/(n_t/10), 0)) { # display progress every 10%
cat('\r', paste(t/n_t * 100, "% done", sep = " "))
}
} # close the loop for the time points
# calculate
tc <- m_C %*% v_dwc    # total (discounted) cost per individual
te <- m_E %*% v_dwe    # total (discounted) QALYs per individual
tc_hat <- mean(tc)     # average (discounted) cost
te_hat <- mean(te)     # average (discounted) QALYs
# store the results from the simulation in a list
results <- list(m_M = m_M, m_C = m_C, m_E = m_E, tc = tc , te = te, tc_hat = tc_hat, te_hat = te_hat)
return(results)  # return the results
} # end of the MicroSim function
# By specifying all the arguments in the `MicroSim()` the simulation can be started
# In this example the outcomes are of the simulation are stored in the variables `outcomes_no_tr` and `outcomes_trt`.
# Run the simulation model
outcomes <- MicroSim(n_i, df_X, seed = 1)
# Show results
results  <- data.frame("Total Cost" = outcomes$tc_hat, "Total QALYs" = outcomes$te_hat)
results
#### 07 Visualize results ####
options(scipen = 999)
plot_tc(outcomes$tc)    # density of total costs
# ggsave("figs/microoutcomes_sick_sicker/microoutcomes_sick_sicker_cost_density_no_trt.png", plot = plot_tc(outcomes_no_trt$tc), width = 8, height = 6)
plot_te(outcomes$te)    # density of total QALYs
# ggsave("figs/microoutcomes_sick_sicker/microoutcomes_sick_sicker_eff_density_no_trt.png", plot = plot_te(outcomes_no_trt$te), width = 8, height = 6)
plot_m_TR(outcomes$m_M) # health state trace
# ggsave("figs/microoutcomes_sick_sicker/microoutcomes_sick_sicker_eff_density_trt.png", plot = plot_te(outcomes_trt$te), width = 8, height = 6)
#### 08 Probabilistic Sensitivity Analysis (PSA) ####
### Function that generates random sample for PSA
gen_psa <- function(n_sim = 1000, seed = 071818){
set.seed(seed) # set a seed to be able to reproduce the same results
df_psa <- data.frame(
# Transition probabilities (per cycle)
p_HS    = rbeta(n_sim, 24, 450)                        , # probability to become sick when healthy
# Cost vectors with length n_sim
c_H     = rgamma(n_sim, shape = 225, scale = 6.65)     , # cost of remaining one cycle in state H
c_S     = rgamma(n_sim, shape = 625, scale = 8)        , # cost of remaining one cycle in state S1
c_D     = 0                                            , # cost of being in the death state
# Utility vectors with length n_sim
u_H     = rbeta(n_sim, 9, 0.009)                       , # utility when healthy
u_S     = rbeta(n_sim ,10, 1.75)                       , # utility when sick
u_D     = 0                                              # utility when dead
)
return(df_psa)
}
# Try it
gen_psa(10)
### Decrease number of individuals since PSA takes a lot of time
n_i <- 50
### update Sample individual level characteristics
# Static characteristics
v_sex    <- sample(x = c("Female", "Male"), prob = c(0.5, 0.5), size = n_i, replace = TRUE) # randomly sample the sex of an individual (50% female)
df_X     <- data.frame(ID = 1:n_i, Sex = v_sex)
# Dynamic characteristics
# Specify the initial health state of the individuals
# everyone begins in the healthy state (in this example)
v_M_init <- rep("healthy", times = n_i)
v_Ts_init <- rep(0, n_i)         # a vector with the time of being sick at the start of the model
### Number of simulations
n_sim <- 1000
### Generate PSA input dataset
df_psa_input <- gen_psa(n_sim = n_sim)
## First six observations
head(df_psa_input)
## Histogram of parameters
ggplot(melt(df_psa_input, variable.name = "Parameter"), aes(x = value)) +
facet_wrap(~Parameter, scales = "free") +
geom_histogram(aes(y = ..density..)) +
theme_bw(base_size = 16)
# ggsave("figs/microsim_sick_sicker/microsim_sicksicker_PSA_parameters.png", width = 10, height = 6)
### Initialize dataframes with PSA output
# Dataframe of costs
df_c <- as.data.frame(matrix(0,
nrow = n_sim,
ncol = 1))
# Dataframe of effectiveness
df_e <- as.data.frame(matrix(0,
nrow = n_sim,
ncol = 1))
#### 08.1 Load function of microsimulation model ####
source("Function_Microsim_3-state_time.R")
# Test microsimulation function
calculate_ce_out(df_psa_input[1,])
#### 08.2 Run microsimulation model on each parameter set of PSA input dataset
for(i in 1:n_sim){
df_out_temp <- calculate_ce_out(df_psa_input[i, ])
df_c[i, ] <- df_out_temp$Cost
df_e[i, ] <- df_out_temp$Effect
# Display simulation progress
if(i/(n_sim/10) == round(i/(n_sim/10),0)) { # display progress every 10%
cat('\r', paste('            ', 'Overall: ', i/n_sim * 100, "% done", sep = " "))
}
}
df_c
df_e
out_psa
?make_psa_obj
#### 08.3 Cost Effectiveness Analysis ####
# make an PSA object using dampack
out_psa  <- make_psa_obj(df_c, df_e, df_psa_input, v_names_str = NULL, "$")
#### 08.3 Cost Effectiveness Analysis ####
# make an PSA object using dampack
out_psa  <- make_psa_obj(df_c, df_e, df_psa_input, strategies = NULL, "$")
#### 08.3.2 Cost-Effectiveness Acceptability Curves (CEAC) and Frontier (CEAF) ####
out_ceaf <- ceac(v_wtp, out_psa)
### Vector with willingness-to-pay (WTP) thresholds
v_wtp <- seq(0, 300000, by = 10000)
#### 08.3 Cost Effectiveness Analysis ####
# make an PSA object using dampack
out_psa  <- make_psa_obj(df_c, df_e, df_psa_input, strategies = NULL, "$")
#### 08.3.2 Cost-Effectiveness Acceptability Curves (CEAC) and Frontier (CEAF) ####
out_ceaf <- ceac(v_wtp, out_psa)
plot(out_ceaf)
#### 08.3.3 Cost-Effectiveness Scatter plot ####
plot(out_psa)
plot(df_c)
plot(df_e, df_c)
plot(df_e$V1, df_c$V1)
#### 08.3.3 Cost-Effectiveness Scatter plot ####
plot(out_psa)
#### 08.3.4 Expected Value of Perfect Information (EVPI) ####
out_evpi <- calc_evpi(v_wtp, out_psa)
plot(out_evpi)
out_psa
colnames(df_c) <- "Cost"
### Initialize dataframes with PSA output
# Dataframe of costs
df_c <- as.data.frame(matrix(0,
nrow = n_sim,
ncol = 1))
colnames(df_c) <- "Cost"
# Dataframe of effectiveness
df_e <- as.data.frame(matrix(0,
nrow = n_sim,
ncol = 1))
colnames(df_e) <- "Effectiveness"
#### 08.1 Load function of microsimulation model ####
source("Function_Microsim_3-state_time.R")
# Test microsimulation function
calculate_ce_out(df_psa_input[1,])
#### 08.2 Run microsimulation model on each parameter set of PSA input dataset
for(i in 1:n_sim){
df_out_temp <- calculate_ce_out(df_psa_input[i, ])
df_c[i, ] <- df_out_temp$Cost
df_e[i, ] <- df_out_temp$Effect
# Display simulation progress
if(i/(n_sim/10) == round(i/(n_sim/10),0)) { # display progress every 10%
cat('\r', paste('            ', 'Overall progress: ', i/n_sim * 100, "% done", sep = " "))
}
}
#### 08.3 Cost Effectiveness Analysis ####
# make an PSA object using dampack
out_psa  <- make_psa_obj(df_c, df_e, df_psa_input, strategies = NULL, "$")
# Total cost and effectiveness
results  <- data.frame("Total Cost" = mean(out_psa$Cost), "Total QALYs" = mean(out_psa$Effect))
results
out_psa
# Total cost and effectiveness
results  <- data.frame("Total Cost" = mean(out_psa$cost), "Total QALYs" = mean(out_psa$effectiveness))
out_psa$cost
out_psa$cost
head(out_psa$cost)
head(out_psa$effectiveness)
# Total cost and effectiveness
results  <- data.frame("Total Cost" = mean(out_psa$cost[,1]), "Total QALYs" = mean(out_psa$effectiveness[,1]))
results
# Cost-Effectiveness Scatter plot
plot(out_psa)
